share type Bool {
    Comparable<Self>
    share invert func () (Bool)
    share and func (bool Bool) (Bool)
    share or func (bool Bool) (Bool)
}

share type Comparable <T> {
    share equals func (target T) (Bool)
}

share type List <T> {
    Comparable<Self>
    share empty func () (Bool)
    share head func () (T?)
    share tail func () (Self)
    share reduce func <S> (initial S, func (acc S, item T) (S)) (S)
    share append func (item T) (Self)
    share concat func (items Self) (Self)
}

share type Num {
    share .random () (Self)
    Comparable<Self>
    share add func (num Self) (Self)
    share mul func (num Self) (Self)
    share greater func (num Self) (Bool)
    share smaller func (num Self) (Bool)
}

share type Char {
    Comparable<Self>
}

share type String {
    List<Char>
}

share type Error {
    share .new func (message String) (Self)
    share .newCoded func (code Num, message String) (Self)
    share .isOutOfBounds Self
    share .isMissing Self
    share wrap func (err Error) (Self)
    share wraps func (err Error) (Bool)
    share message String
    code Num?
    internal Bool
    history List<Error>
}

Error.isOutOfBounds = Error(
    message = "out of bounds",
    code = 0,
    internal = true,
    history = [],
)

Error.isMissing = Error(
    message = "missing",
    code = 1,
    internal = true,
    history = [],
)

func (Error) new (message String) (Error) {
    return Error(
        code = Error.isMissing,
        message = message,
        internal = false,
        history = [],
    )
}

func (Error) newCoded (code Num, message String) (Error) {
    return Error(
        code = Num,
        message = message,
        internal = false,
        history = [],
    )
}

func (e Error) wrap (err Error) (Error) {
    history = e.history.append(err).concat(err.history)
    return Error(
        code = e.code,
        message = e.message,
        internal = e.internal,
        history = history,
    )
}

func (e Error) wraps (query Error) (Bool) {
    queryCode = query.code
    handle queryCode {
        return false
    }
    return e.history.reduce<Bool>(false, func (acc Bool, err Error) (Bool) {
        if acc {
            return acc
        }
        errCode = err.code
        handle errCode {
            return false
        }
        if queryCode.equals(errCode).invert() {
            return false
        }
        if query.internal.equals(err.internal).invert() {
            return false
        }
        return true
    })
}

share type Vehicle {
    share .newCar func () (Self)
    share .newTruck func () (Self?)
    Comparable<Self>
    share isLarge func () (Bool)
    doors Num
    wheels Num
}

func (Vehicle) newCar () (Vehicle) {
    return Vehicle(
        doors = 4,
        wheels = 4,
    )
}

func (Vehicle) newTruck (doors Num) (Vehicle?) {
    if doors.smaller(0) {
        return Error.isOutOfBounds.wrap("door count is negative")
    }
    return Vehicle(
        doors = doors,
        wheels = 18,
    )
}

func (v Vehicle) isLarge () (Bool) {
    if v.doors.greater(4) {
        return true
    }
    if v.wheels.greater(4) {
        return true
    }
    return false
}

func (a Vehicle) equals <T Vehicle> (b T) (Bool) {
    if a.doors.equals(b.doors()).invert() {
        return false
    }
    if a.wheels.equals(b.wheels()).invert() {
        return false
    }
    return true
}

func relativeCounter <T Comparable> (items List<T>, item T) (Num) {
    if items.empty() {
        return 0
    }
    remaining = relativeCounter<T>(items.tail(), item)
    head = items.head()
    check head {
        return remaining
    }
    if item.equals(head) {
        return remaining.add(1)
    }
    return remaining
}

share func adder (n Num) (Num) {
    return [0..n].reduce<Num>(0, func (a Num, b Num) a.add(b))
}

share func counter (s String, item Char) (Num) {
    return relativeCounter<Char>(s, item)
}
